\documentclass[sigconf]{acmart}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tikz-cd}
\usepackage[nameinlink,sort]{cleveref}
\usepackage{microtype}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage[shortlabels]{enumitem}
\usepackage{xspace}
\usepackage{nameref}
\usepackage[svgnames]{xcolor}
\usepackage{proof}
\usepackage{minted}
\setminted{bgcolor=Beige,autogobble,breaklines,breakafter={}}
\usepackage{listings}
\renewcommand\UrlFont{\color{blue}\rmfamily}
% \usepackage{color}
% \usepackage{amssymb}
% \usepackage{syntax}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{bussproofs}

\title{A Framework for Controlled Key Release}

\author{Logan Schmalz}
\email{loganschmalz@ku.edu}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{University of Kansas}
  \city{Lawrence}
  \state{Kansas}
  \country{USA}
}

\author{Second Author}
\email{\{authors\}@ku.edu}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{University of Kansas}
  \city{Lawrence}
  \state{Kansas}
  \country{USA}
}

\begin{document}

\begin{abstract}
Modern security relies heavily on public key cryptography,
and it is necessary to protect private keys, and secrets in general, from attackers.
While multiple mechanisms exist to prevent secrets from being trivially read off the filesystem,
against a highly-capable adversary it is ideal to store secrets outside of main memory.
The TPM 2.0 is built into modern x86 hardware and is designed to be used for exactly this.
However, a lack of tight integration between the TPM and the operating system makes it difficult to protect secrets with high availability needs from arbitrary access.
% fails to protect keys stored in the TPM 2.0 from being used by arbitrary users, other than by fully restricting access to the TPM.
Using only existing infrastructure: SELinux, IMA, and LUKS containers,
we develop a stronger protection mechanism for TPM-stored secrets so access can be restricted to a specific program or user,
without limiting access to the TPM in general.

% \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\maketitle              % typeset the header of the contribution
%
%
%
%
\section{Introduction}
Public key cryptography is a key component of modern security, to the point where it is expected that almost any communication on the Internet is encrypted and has signatures.
However, it relies on the assumption that private keys are kept secret.
When the data being transmitted is emails, and the correspondents have met in real life,
it is easy to trust that the other person is conscientious of the security of their key.
However, when the data being transmitted is a webpage utilizing TLS, from a server that gets thousands of requests per second,
suddenly the security of the keys depends on the configurations and automated processes of the machines involved.
And when the data being transmitted is evidence that a gamer is not running cheats on their computer,
letting evidence be controlled by users is detrimental.

A root-level compromise to a system is often considered game-ending,
and systems are designed to prevent such from occurring.
While this is obviously a good design principle, despite our best efforts,
sometimes adversaries gain root capabilities.
So how do we protect secrets like private keys from root-level attackers?

One idea to help protect secrets is to store them outside the main memory of the machine,
and never bring them into main memory.
The Trusted Platform Module 2.0 (TPM 2.0) is designed to do exactly this.
It serves as a root of trust of storage for private keys and other secrets,
and even includes features like authorization requirements via passwords to access them.
However, the authorization features can either be satisfied by any program on the machine or require input of a password or other form of manual user verification.
In other words, the TPM does not tightly integrate with the operating system, such that it could recognize what user or program on the operating system is trying to use any given key without manual input.
In the case of TLS on a webserver, having an administrator input a password every time a request is made is impossible.
For a key that needs to be made available without manual user input,
against a root-level adversary, or even the wrong program attempting to use a private key,
there is no meaningful built-in authorization method that protects the key.

However, the TPM is also capable of storing firmware and boot measurements taken by the UEFI as part of its feature set,
primarily to establish integrity of the system during the boot process.
For example, this is how Secure Boot works.
Using these features, we can ensure that Security-Enhanced Linux (SELinux) and the Linux Integrity Measurement Architecture (IMA)
are enabled on a system with the correct configuration, and utilize these kernel-level security mechanisms to help protect TPM keys.

The SELinux and IMA policies, the assisting boot-time setup and measurements,
and the TPM configuration necessary to accomplish this are the key contributions of our work.
Through these mechanisms, we take a step towards deeper operating system integration with TPM authorization without needing new hardware.
We also recognize that integrating other TPM mechanisms, such as localities or resettable PCRs, into Linux kernel would allow improved implementations.

\section{Background}
It is important to understand how these mechanisms work for our strategy to work as expected.
Additionally, all of the mechanisms we utilize have subtleties in implementation which are either extremely important to the security of the system or challenging to develop.

\subsection{Trusted Platform Module 2.0}
The TPM 2.0 is widely available on modern x86 machines, as it is integrated into AMD and Intel's CPU firmware (sometimes referred to as fTPM).
It is also possible to purchase hardware TPM 2.0 modules if necessary.
Thus it is a good target for our work, since it is common and provides a portion of the capabilities we desire for protecting keys.
\subsubsection{Recording Boot Measurements}
A TPM 2.0 must have at least sixteen Platform Configuration Registers (PCRs).
PCRs can store hashes of system integrity measurements or other values through hash extension operations.
If a PCR has a current hash value $x$, and it is being extended with a new hash $y$,
the PCR's new value will become $x_{new} = \mathop{hash}(\mathop{concat}(x,y))$.
By recording each hash that a PCR has been extended with and correlating it to a source,
successfully manually reconstructing the value in a PCR effectively guarantees integrity of the correlated measurements.
For good hash functions like SHA-256, 
%it is considered extremely difficult to, given any $x$, come up with some $y$ such that $x_{new}$ is a particular value.
%In other words, 
it is effectively impossible for an adversary to discover a new $y$ which would allow $x_{new}$ to lie about any measurements that have been taken before hand.

This is the primary mechanism behind Secure Boot and other measured or trusted boot strategies.
When a machine boots, its UEFI takes measurements of system firmware and of the bootloader and stores them in PCRs,
then the bootloader takes measurements of the kernel and other parts of the operating system and stores them in PCRs as well.
Since the user does not have control during this early boot-time, the measurements taken suggest either integrity or alteration of the firmware and software.
The first sixteen PCRs are non-resettable: they cannot be reset to their initial values (typically 0) except by fully rebooting the system.
This makes TPM PCRs a trustworthy place to store boot measurements during system runtime.

\subsubsection{Protecting Keys and Other Secrets}
Most TPM-resident secrets (e.g. private keys) are only usable within the TPM.
Because the TPM is very limited in resources, it is not necessarily capable of permanently storing every key.
When TPM-resident objects need to be stored elsewhere, i.e. on the filesystem, due to these limitations,
they are encrypted so they can only be used if they are reloaded into the same TPM.
Note that having a key loaded in the TPM does not mean the TPM will allow use of the key arbitrarily.
Think of keys loaded in the TPM as being in the cache, so they can be evicted from the cache and reloaded as necessary.

It is possible to require certain conditions to be met to use a TPM-resident key.
This can involve requiring a password, HMAC, a particular set of expected PCR values,
or a more general "policy" to be satisfied.
Using a password or HMAC effectively requires a secret to be known at the time of key usage.
However, secrets like passwords obviously have no inherent protection mechanisms.
Using PCRs effectively limits usage of a key to an administrator-approved boot configuration.
Policy-based authorization is more advanced.

TPM keys are tied to the password or policy required to use them.
For passwords-authorized keys, there are methods to change the password;
the key is then relocated and must be reloaded.
For simple PCR-based authorization,
there is no mechanism to change the expected PCRs,
which causes problems across system updates.

On the other hand,
it is possible to change the policy required for a policy-authorized key by using a ``wildcard policy'' or ``authorized policy''.
Wildcard policies must be signed by an administrator with a private key that is associated with a public key
which is included as part of the details when setting up the TPM-resident key.
Fortunately for us, a policy can also include PCR checks.
Since it is possible to allow polices to change via wildcard policies,
it is possible to create a key with changeable PCR requirements.
This means that a TPM key protected by a policy can remain usable across system updates that may change boot PCRs.
Wildcard policies can also be leveraged to explicitly allow multiple policies to authorize access to a single key,
or utilize the same policy for different keys, including keys on different devices.
\subsection{SELinux}

\subsection{Integrity Measurement Architecture}
\subsubsection{Signing Files}
(hashes vs. signing, x509 keys, machine owner keys)

\subsection{LUKS Containers}

\section{Implementation}
\subsection{SELinux Policy}
\subsection{IMA Policy}
\subsection{Boot-time and Initramfs Measurements}

\section{Limitations and Alternatives}


%
% 
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
%\bibliographystyle{splncs04}
\bibliographystyle{splncsnat}
%\bibliography{sldg}
\bibliography{bib/sldg}
%
\end{document}
