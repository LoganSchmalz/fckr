\documentclass[sigconf]{acmart}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tikz-cd}
\usepackage[nameinlink,sort]{cleveref}
\usepackage{microtype}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage[shortlabels]{enumitem}
\usepackage{xspace}
\usepackage{nameref}
\usepackage[svgnames]{xcolor}
\usepackage{proof}
\usepackage{minted}
\setminted{bgcolor=Beige,autogobble,breaklines,breakafter={}}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\footnotesize,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  breakatwhitespace=true,
  frame=single,
  framerule=0pt,
  backgroundcolor=\color{lightgray},
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}
\renewcommand\UrlFont{\color{blue}\rmfamily}
% \usepackage{color}
% \usepackage{amssymb}
% \usepackage{syntax}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{bussproofs}

\title{A Framework for Controlled Key Release}

% TODO : orcids
\author{Logan Schmalz}
\email{loganschmalz@ku.edu}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{University of Kansas}
  \city{Lawrence}
  \state{Kansas}
  \country{USA}
}

\author{Perry Alexander}
\email{palexand@ku.edu}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{University of Kansas}
  \city{Lawrence}
  \state{Kansas}
  \country{USA}
}

\newcommand{\tpmsign}{\texttt{tpm\_sign}\xspace}
\newcommand{\wcp}{\texttt{WCP}\xspace}
\newcommand{\pk}{\texttt{SK}\xspace}

\begin{document}

\begin{abstract}
Modern security relies heavily on public key cryptography,
and it is necessary to protect private keys, and secrets in general, from attackers.
While multiple mechanisms exist to prevent secrets from being trivially read off the filesystem,
against a highly-capable adversary it is ideal to store secrets outside of main memory.
The TPM 2.0 is built into modern x86 hardware and is designed to be used for exactly this.
However, a lack of tight integration between the TPM and the operating system makes it difficult to protect secrets with high availability needs from arbitrary access.
% fails to protect keys stored in the TPM 2.0 from being used by arbitrary users, other than by fully restricting access to the TPM.
Using only existing infrastructure: SELinux, IMA, and LUKS containers,
we develop a stronger protection mechanism for TPM-stored secrets so access can be restricted to a specific program or user,
without limiting access to the TPM in general.

% \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\maketitle              % typeset the header of the contribution
%
%
%
%
\section{Introduction}
Public key cryptography is a key component of modern security, and is now ubiquitous: most Internet communication is encrypted and authenticated.  % signed ?
However, this security relies on the assumption that private keys are kept secret.
In small-scale, personal settings, users can reasonably trust one another to protect their keys.
In contrast, large-scale systems such as TLS-enabled web servers handle thousands of requests per second, and the security of their keys depends entirely on machine configuration and automated processes.
In such settings, keys must be both highly availabe and strongly protected.
% When the data being transmitted is emails, and the correspondents have met in real life,
% it is easy to trust that the other person is conscientious of the security of their key.
% However, when the data being transmitted is a webpage utilizing TLS, from a server that gets thousands of requests per second,
% suddenly the security of the keys depends on the configurations and automated processes of the machines involved.
% TODO: consider reword or cut below
% And when the data being transmitted is evidence that a gamer is not running cheats on their computer,
% letting evidence be controlled by users is detrimental.

A root-level compromise to a system is often catastrophic,
and systems are designed to prevent such events.
Despite best practices, however,
adversaries sometimes gain root capabilities.
This raises a critical question: how can secrets such as private keys be protected even from a root-level attacker, while remaining usable by legitimate services?
% Protecting private keys gainst root-level attackers remains an open-challenge.
% So how do we protect secrets like private keys from root-level attackers?

One approach is to store secrets outside the main memory, 
and never expose them to user-space or even kernel-space.
The Trusted Platform Module 2.0 (TPM 2.0) is designed to do exactly this.
It provides a hardware-backed root of trust for storage of private keys and other secrets,
and supports authorization mechanisms such as passwords to access them.
However, these mechanisms do not integrate tightly with operating system concepts such as users or programs.
Authorization can either be satisfied by any program on the machine or requires manual user input.
For high-availability services such as TLS, manual authorization is infeasible,
and there is no built-in TPM mechanism that meaningfully restricts key usage to a specific user or program in the presence of a root-level adversary.

At the same time, the TPM supports measured and trusted boot through firmware and boot measurements recorded in Platform Configuration Registers (PCRs).
These mechanisms are commonly used to establish system integrity, for example as part of Secure Boot.
By leveraging these measurements, it is possble to ensure that Security-Enhanced Linux (SELinux) and the Linux Integrity Measurement Architecture (IMA)
are enabled with an approved configuration.
These kernel-level mechanisms can then be used to enforce fine-grained access control over TPM-resident resources.

In this work, we demonstrate how existing infrastructure---SELinux, IMA, and LUKS containers---can be combined with
TPM policy authorization to restrict access to TPM-resident secrets to specific programs or users,
without globally restricting access to the TPM.
We describe the required SELinux and IMA policies, boot-time measurements, and TPM configuration necessary to achieve this.
Finally, we discuss limitations of current TPM integration and note that deeper kernel support for features such as TPM localities or resettable PCRs could enable stronger future designs.
% The SELinux and IMA policies, the assisting boot-time setup and measurements,
% and the TPM configuration necessary to accomplish this are the key contributions of our work.
% Through these mechanisms, we take a step towards deeper operating system integration with TPM authorization without needing new hardware.
% We also recognize that integrating other TPM mechanisms, such as localities or resettable PCRs, into Linux kernel would allow improved implementations.

\section{Background}
Understanding how these mechanisms work is necessary for our strategy to behave as intended,
as each involves subtleties that significantly affect system security.
% TODO: improve flow

\subsection{Trusted Platform Module 2.0}
The TPM 2.0 is widely available on modern x86 systems, 
either as firmware TPMs (fTPMs) integrated in AMD and Intel platforms or as discrete hardware modules,
making it a practical target for our work.
% Thus it is a good target for our work, since it is common and provides a portion of the capabilities we desire for protecting keys.
The behavior of the TPM is standardized by the Trusted Computing Group (TCG).

\subsubsection{Recording Boot Measurements}
A TPM 2.0 must have at least sixteen Platform Configuration Registers (PCRs).
PCRs can store hashes of system integrity measurements or other values through hash extension operations.
If a PCR has a current hash value $x$, and it is being extended with a new hash $y$,
the PCR's new value will become $x_{new} = \mathop{hash}(\mathop{concat}(x,y))$.
By correlating each hash extension to its source,
successfully reconstructing a PCR value demonstrates integrity of the recorded measurements.
For good hash functions like SHA-256, 
it is effectively impossible for an adversary to discover a new $y$ which would allow $x_{new}$ to lie about any measurements that have been taken beforehand.

This is the primary mechanism behind Secure Boot and other measured or trusted boot strategies.
When a machine boots, its UEFI takes measurements of system firmware and of the bootloader and stores them in PCRs,
then the bootloader takes measurements of the kernel and other parts of the operating system and stores them in PCRs as well.
Because users lack control during boot,
these measurements reliably indicate firmware and software integrity.
Additionally, the first sixteen PCRs are non-resettable and persist until reboot.
This makes TPM PCRs a trustworthy place to store boot measurements during system runtime.

\subsubsection{Protecting Keys and Other Secrets}\label{sec:key-protections}
Most TPM-resident secrets (e.g. private keys) are only usable within the TPM.
When TPM-resident objects need to be stored elsewhere, i.e. on the filesystem, due to the TPM's limited resources,
they are encrypted so they can only be used if they are reloaded into the same TPM.
Loading a key in the TPM merely caches it; authorization checks are still enforced on use,
and the key may be evicted and reloaded as necessary.

It is possible to require certain conditions to be met to use a TPM-resident key.
This can involve requiring a password, HMAC, a particular set of expected PCR values,
or a more general "policy" to be satisfied.
Password- or HMAC-based authorization requires a secret to be known at use time,
but such secrets have no inherent protection against disclosure.
Using PCRs effectively limits usage of a key to an administrator-approved boot configuration.
Policy-based authorization is more advanced.

TPM keys are tied to the password or policy required to use them.
For passwords-authorized keys, there are methods to change the password;
the key is then relocated and must be reloaded.
For simple PCR-based authorization,
there is no mechanism to change the expected PCRs,
which causes problems across system updates.

On the other hand,
it is possible to change the policy required for a policy-authorized key by using a ``wildcard policy'' or ``authorized policy''.
Wildcard policies must be signed by an administrator with a private key that is associated with a public key
which is included as part of the details when setting up the TPM-resident key.
Policies may also include PCR checks.
Because wildcard policies can be updated,
keys can have changeable PCR requirements and remain usable after system updates that modify boot measurements.
Wildcard policies may also be leveraged to explicitly allow multiple policies to authorize access to a single key,
or to utilize the same policy for different keys, including keys on different devices.

\subsection{Security-Enhanced Linux}
SELinux provides mandatory access controls on Linux and is available by default in most distributions.
Labels added to users, files, and processes determine their permissions according to the SELinux policy installed on the system.
These permissions can control actions such as reading and writing to certain files (including append-only writes),
executing programs, inter-process communication, and opening specific network ports.
We will use SELinux to protect TPM-related files.

\subsection{Integrity Measurement Architecture}
The Linux Integrity Measurement Architecture (IMA) primarily measures files and prevents them from being opened or executed if they are changed from an approved state.
Like SELinux, IMA is widely available by default.
When IMA is enabled in \texttt{fix} mode, all files that get matched by the IMA policy get hashes added as extended file-system attributes.
In \texttt{appraise} mode, IMA prevents protected files from being opened if their contents do not match the approved hash.
The IMA policy can include various specifications such as file owners, the active user, and whether files are being opened for reading or execution.
The first custom IMA policy that is loaded overwrites any default policies.
Afterwards, the custom IMA policy cannot be overwritten, only appended to.

\subsubsection{Signing Files}
It is also possible to use signatures instead of hashes to detect corruption of files.
This allows for more dynamicity in the system, since switching IMA from \texttt{appraise} mode to \texttt{fix} mode requires a system-reboot.
Allowing hashes to be overwritten at runtime is unsafe, as an adversary may know the expected value.
In contrast, signatures can be updated safely because the administrator's signing key remains protected.

By default, some distributions require any custom IMA policies and public keys that get loaded to be signed by an administrator.
This involves adding a key certificate to the UEFI Machine Owner Keys, then signing IMA policies and X.509 keys on the filesystem with the appropriate private key.

\subsubsection{Extended Verification Module}
The Extended Verification Module (EVM) additionally protects file metadata, such as the permissions and SELinux label.
This is valuable to ensure an adversary cannot simply adjust file metadata to bypass SELinux or IMA protections.
EVM can be put into a mode where it uses HMAC to detect any offline filesystem modifications, or a mode where it uses signatures to detect runtime modifications as well.

\subsection{LUKS Containers}
Linux Unified Key Setup (LUKS) containers can be used to encrypt specific files on the filesystem.
By encrypting the container with a key protected by TPM PCRs,
it can be used protect files associated with secrets when the system might boot in an unapproved state.

\subsection{Limitations of Available Mechanisms}
As key protections were discussed in \ref{sec:key-protections},
notice the TPM lacks authorization mechanisms that integrate directly with operating system concepts such as user permissions or programs.
The TPM has a feature called ``localities'' which is intended to be used to indicate the origin of a command (hardware, kernel, user-level software).
In theory, using a specific locality to restrict a secret to one program is a good idea.
However, the TPM trusts the operating system to control localities, and there is no existing mechanism, SELinux included, designed to accomplish this.

% TODO: optional?
% While IMA is powerful,
% complex policy configurations can place systems into states that prevent successful boot without reverting to \texttt{fix} mode.

\section{Implementation}
In our implementation, access to the TPM key \pk is restricted to a single program, which we denote \tpmsign,
since the key is used for generating signatures.
Enforcement of this restriction is handled by SELinux policy.
IMA is used to protect the integrity of \tpmsign, as well as any binaries permitted to invoke it.
EVM protects the SELinux labels on \tpmsign and related files, preventing metadata tampering.
Additionally, SELinux policy restricts relabeling of these files to and from the \tpmsign-specific labels.
These protections are strongest when the SELinux policy is designated immutable,
preventing runtime policy modification by an adversary.

\tpmsign utilizes wildcard policy \wcp which is the secret to access \pk.
\wcp as the secret requires the PCRs to indicate the system booted in a state where \wcp is protected by SELinux and IMA.
If \wcp is unprotected, the PCRs will indicate such, so \pk will not be usable.

\wcp is stored within a LUKS container which automatically unlocks during boot if the boot process is executing as expected.
In the case where an adversary reboots the system into an unapproved state, \wcp is encrypted inside the LUKS container and cannot be accessed.
Thus, for an adversary to access \wcp, they must exploit the running system to figure out how to disable the IMA or SELinux policies,
or otherwise find an exploit to read \wcp from memory or from the filesystem bypassing protections.

Our development system uses Fedora 42 with an out-of-the-box kernel.

\subsection{SELinux Policy}
% policy_module(tpm_sign, 1.0.0)
% require {
%         type unconfined_t;
%         role unconfined_r;
%         type kernel_t;
%         type init_t;
%         type initrc_t;
%         type user_home_dir_t;
% }

The following SELinux policy (slightly condensed for presentation)
establishes four types:
\lstinline|tpm_sign_t| for the \tpmsign executing domain, \lstinline|tpm_sign_exec_t| for the \tpmsign binary label,
\lstinline|tpm_sign_file_t| for protected files, and \lstinline|vault_mnt_t| for the LUKS container.
% ? These can be included in the <file contexts> file if desired.
We do not use \lstinline|files_type(tpm_sign_file_t)| because it automatically allows access by unconfined processes,
but we want to restrict \lstinline|tpm_sign_file_t| to only \tpmsign. % TODO: cite https://unix.stackexchange.com/questions/729329/selinux-deny-access-to-my-custom-type-for-unconfined-t-processes
In our development environment, these rules prevent the appropriate files from being accessed via any route other than \tpmsign.
\begin{lstlisting}
type tpm_sign_t; domain_type(tpm_sign_t);
type tpm_sign_exec_t; files_type(tpm_sign_exec_t);
type vault_mnt_t; files_type(vault_mnt_t);
fs_associate(vault_mnt_t);

type tpm_sign_file_t;
# Do not use files_type(), it allows some things we don't want
fs_associate(tpm_sign_file_t);
allow tpm_sign_t tpm_sign_file_t:file { read open create getattr };
# Automatically label any created files
type_transition tpm_sign_exec_t user_home_dir_t:file
  tpm_sign_file_t;

allow tpm_sign_t tpm_sign_exec_t : file { ioctl read getattr lock
  execute execute_no_trans entrypoint open } ;
allow tpm_sign_t vault_mnt_t : dir { read write add_name
  remove_name };
\end{lstlisting}
% TODO: cut line about automatic labelling?

We also utilize a short cil policy to enforce explicit deny rules. % TODO: cil stylization
Deny rules are capable of overriding the SELinux policy to prevent otherwise allowed operations.
The following rules prevent even a root user from relabeling a malicious program to \lstinline|tpm_sign_exec_t| or removing protections from \lstinline|tpm_sign_file_t| files.
\begin{lstlisting}
(deny domain tpm_sign_exec_t (file (relabelto)))
(deny domain tpm_sign_file_t (file (relabelfrom)))
\end{lstlisting}

We utilize the following rules in our development environment,
which must be strictly adjusted for real-world systems.
If utilizing a \tpmsign binary, only trusted programs should be able to execute it.
This can be done by creating other types for those trusted programs and replacing the types below.
Additionally, we allow the \lstinline|tpm_sign_t| domain to be unconfined since we trust our \tpmsign program,
but restricting its permissions is probably reasonable as well.
\begin{lstlisting}
type_transition unconfined_t tpm_sign_exec_t : process tpm_sign_t;
allow unconfined_t tpm_sign_t : process { transition siginh
  rlimitinh noatsecure };
role unconfined_r types { tpm_sign_t tpm_sign_exec_t };
unconfined_domain(tpm_sign_t);
\end{lstlisting}
% TODO: allow anyone to delete file?

We recommend making SELinux state immutable with the following command:
 ... %TODO
However, we acknowledge this may not always be possible.
In that case, deeper investigation into protecting the system via IMA is probably necessary, and unfortunately highly system-specific.

Since SELinux policy is often considered frustrating to work with,
we attempted to minimize our reliance on SELinux.
Additionally, support for deny rules was finalized during our work on this project,
thus we initially explored alternative mechanisms to further protect our TPM-related files.
Concerned about an adversary either replacing the \tpmsign binary with a malicious version or
modifying the SELinux labels on files we care about, we turned to IMA and EVM.
Further, for our research outside this particular work, we must protect other infrastructure which interacts with
the \tpmsign binary.
While it is likely these concerns could be solved with a well-designed, immutable SELinux policy and extensive boot measurements,
we continue to believe developing relevant IMA-based protections is slightly easier to understand and can add an additional layer of protection.

\subsection{IMA Policy}
We need IMA policy to protect the integrity of \tpmsign binary and relevant files.
We base our policy off of the default \verb|tcb| and \verb|appraise_tcb| policies.
We include the following lines in our IMA policy:
\begin{lstlisting}
appraise obj_type=tpm_sign_exec_t appraise_type=imasig
appraise obj_type=tpm_sign_files_t appraise_type=imasig
\end{lstlisting}
By using \lstinline|appraise_type=imasig| to require signatures for these files,
it is possible to modify the files without rebooting the system and get a remote administrator's signature to correct IMA's expected value.
This can make it easier to update relevant files if necessary.

Alternative policies may exist. For example, it may be reasonable to make all these files owned by a particular user,
and protect them based on the file owner.
More complex policies may be able to provide defense on systems where the SELinux state cannot be immutable
(although this likely makes the system far more difficult to work with than making SELinux state immutable).
For example, on high-security systems, it may even be reasonable to appraise every executed file.
For better protections, we recommend at least including the rules of the available default IMA policies.

While IMA protects from modified files, it does not prevent changing the SELinux label or changing the file owner.
EVM can be used to protect this metadata.
We recommend using EVM ``portable'' signatures on files whose metadata should not change\footnote{
Using non-portable signatures may allow EVM to replace the signature with an HMAC at runtime when EVM HMAC functionality is enabled.
We found disabling the HMAC functionality caused issues in our Fedora development environment.
}.
This actively protects against modifying metadata: although IMA prevents \emph{the operation} from occuring \emph{if the file is corrupt},
it does not inherently prevent initial corruption from occuring;
when using EVM portable signatures, any modification to the file's \emph{metadata} will be outright prevented.
% TODO: allow anyone to delete file? for the purposes of updating
In fact, this occurs regardless of whether the file is matched in the IMA policy.
This makes it impossible to change the SELinux labels, file owners, or UNIX permissions on the file.

Below is an example to sign a file with an EVM portable signature.
In a high security environment, the private key should be held on a separate machine
and the signature should be assigned manually to the file via \lstinline|setfattr|.
\begin{lstlisting}
evmctl sign --imasig --portable file -k key.priv
\end{lstlisting}

Particularly, using an EVM signature on \wcp prevents an adversary from changing its SELinux label.
Then, the IMA policy rules above effectively prevent an adversary from relabeling a malicious binary
to \lstinline|tpm_sign_exec_t|, since all files with that label require an adminstrator's signature.

\subsection{Boot-time and Initramfs Measurements}
On our Fedora system, we add a custom \texttt{dracut} module with a script that measures the IMA and SELinux policies
as well as the \texttt{systemd} init binary on the root filesystem.
We measure \texttt{systemd} because, on Fedora, \texttt{systemd} is responsible for loading the custom IMA and SELinux policies when the full system init occurs\footnotemark.
\footnotetext{
  We found loading IMA and SELinux policy manually during initramfs causes problems on Fedora. On other distributions,
  loading the IMA and SELinux policy via the measurement script removes the need to measure \texttt{systemd}.
  When the initial IMA policies measure \texttt{systemd} (i.e. \texttt{appraise\_tcb}), manual measurement is optional.
}
The script then attempts to unlock the LUKS container which contains \wcp.

\begin{lstlisting}
#!/bin/sh
INIT="$NEWROOT/usr/bin/init"
SELINUX_POLICY=$(find "$NEWROOT/etc/selinux/targeted/policy" -maxdepth 1 -name 'policy.*' | sort -V | tail -n 1)
IMA_POLICY="$NEWROOT/etc/ima/ima-policy"

INIT_SHA="$(sha256sum "$INIT" | cut -d' ' -f1)"
tpm2_pcrextend 11:sha256="$INIT_SHA"
# ... similar for SELinux, IMA

IMG_PATH="$NEWROOT/home/user/vault.img"
MAPPER_NAME="vault_mapper"
MOUNT_POINT="$NEWROOT/mnt/vault"
if [ ! -e "$IMG_PATH" ]; then
    exit 1
fi
if ! systemd-cryptsetup attach "$MAPPER_NAME" "$IMG_PATH" - tpm2-device=auto,keyfile-timeout=0,tries=1,nofail; then
    exit 0
fi
for i in $(seq 1 20); do
    [ -b "/dev/mapper/$MAPPER_NAME" ] && break
    sleep 0.1
done
if [ ! -b "/dev/mapper/$MAPPER_NAME" ]; then
    exit 0
fi
mkdir -p "$MOUNT_POINT"
chcon system_u:object_r:vault_mnt_t:s0 "$MOUNT_POINT"
mount "/dev/mapper/$MAPPER_NAME" "$MOUNT_POINT" 
\end{lstlisting}

Since this script is installed in \texttt{initramfs},
removal of the script or other unapproved modifications of the \texttt{initramfs} will be reflected in a PCR.
Thus, it is not possible for an adversary to falsify the measurements made by this script (or its absence).

\subsubsection{Relevant TPM PCRs}
We utilize PCR 11 for our measurements of policies.
Other relevant PCRs are 4, 7, 8, and 9.
The UEFI puts a measurement of the GRUB bootloader in PCR 4\footnotemark.
\footnotetext{
On most out-of-the-box Linux distributions,
the UEFI measures and executes a Microsoft-signed boot shim which measures the real bootloader (e.g. GRUB).
This is an implementation detail to support Secure Boot systems easily for regular users and does not affect the security of the setup,
barring flaws in the signed shim. % TODO: cite Gentoo
}
GRUB puts measurements of the command line arguments into PCR 8,
and measurements of the initramfs and the kernel into PCR 9.
PCR 7 indicates the general Secure Boot states, including the keys used to verify bootup. % TODO: cite Gentoo? PCR listing? TPM docs?
While the usage of PCRs 0--7 is defined by TCG standards, other PCRs may be used differently for different boot setups. % TODO: cite

\subsection{TPM Key Setup}
After rebooting the system with our initramfs changes,
we set up \wcp and \pk.

\subsubsection{Policy Creation}
For our development system, we have the adminstrator's private key available---in a real setup, it should be held on a different machine.
We create the administrator keys with OpenSSL.
\begin{lstlisting}
openssl genrsa -out policy_key_private.pem 2048
openssl rsa -in policy_key_private.pem -out policy_key.pem -pubout
\end{lstlisting}

The public portion of the key must be loaded in the TPM that holds \pk.
The TPM will create a "wildcard policy digest" so \pk can require a wildcard policy.
The important file being created here is \lstinline|authorized.policy|.
\begin{lstlisting}
tpm2_loadexternal -G rsa -C o -u policy_key.pem -c policy_key.ctx -n policy_key.name
tpm2_startauthsession -S session.ctx
tpm2_policyauthorize -S session.ctx -L authorized.policy -n policy_key.name
tpm2_flushcontext session.ctx
\end{lstlisting}

Then the actual \wcp that sets the PCR requirements must be created and signed with the private key created earlier.
The file \lstinline|pcr.policy_desired| is \wcp.
Our commands create the policy on our development machine,
but that is primarily to easily collect the PCR values.
It should be possible to create the policy on another machine when the PCR values are shared.
% TODO : fix for other PCRs
\begin{lstlisting}
tpm2_pcrread -opcr0.sha256 sha256:0
tpm2_startauthsession -S session.ctx
tpm2_policypcr -S session.ctx -l sha256:0 -f pcr0.sha256 -L pcr.policy_desired
tpm2_flushcontext session.ctx
openssl dgst -sha256 -sign policy_key_private.pem -out pcr.signature pcr.policy_desired
\end{lstlisting}
At this point, we protect \wcp with the \lstinline|tpm_sign_files_t| SELinux label.

\subsubsection{Key Creation}
First we create a primary key. Primary keys are deterministically generated by the TPM,
and the same one will be recreated by re-running the following command:
\begin{lstlisting}
tpm2_createprimary -C o -g sha256 -G aes128cfb -c prim.ctx
\end{lstlisting}
Then we create \pk, whose parent key is the primary key.
Non-primary keys are randomly generated,
so this allows us to save \pk and reload it.
\begin{lstlisting}
tpm2_create -u key.pub -r key.priv -g sha256 -G "rsa2048:rsapss:null" -a "sign|fixedtpm|fixedparent|sensitivedataorigin" -C prim.ctx -c signing.ctx -L policy/authorized.policy
tpm2_readpublic -c signing.ctx -o key.pem --format=pem
rm prim.ctx signing.ctx
\end{lstlisting}
The important files here are \lstinline|key.pub| and \lstinline|key.priv|, the public and private portions of \pk.
We also create a PEM format copy of the public key for sharing.

\subsubsection{Using the Signing Key}
Our program \tpmsign is the only program allowed to access
\wcp (\lstinline|pcr.policy_desired|) according to our SELinux setup.
It attempts to reload \pk from a recent session, which are not valid across reboots.
If it fails, it will re-generate the primary key and then load \pk from its file.
To utilize \pk, it follows the standard steps to verify a wildcard policy to authorize key usage.
% TODO : cite example
This is necessary for every usage of \pk.


\subsection{LUKS Container}
We set up a LUKS container to hold \wcp via the following steps:
\begin{lstlisting}
fallocate -l 1GB vault.img
cryptsetup -v luksFormat vault.img
losetup --find --show vault.img
systemd-cryptenroll --wipe-slot=tpm2 --tpm2-device=auto --tpm2-pcrs=4+7+8+9+11 /dev/loop0
losetup -d /dev/loop0
cryptsetup -v luksOpen vault.img vault_mapper
mkfs -t ext4 /dev/mapper/vault_mapper
mkdir -p /mnt/vault/
mount /dev/mapper/vault_mapper /mnt/vault
\end{lstlisting}
Then \wcp must be placed into the container mount and the EVM signature must be applied.

\section{Evaluation}
We experimentally demonstrated the following features of this setup:
\begin{itemize}
  \item Changing the initramfs, kernel, IMA policy, SELinux policy, and other items measured into PCRs results in an unapproved boot state.
  \item When the system is booted in an unapproved state:
  \begin{itemize}
    \item The LUKS container will not open without a password, and \wcp will not be available.
    Thus, \wcp cannot be relabelled either.
    \item If somehow \wcp is available, the PCRs specified in \wcp will not match and \pk will not be usable.
    Thus, the contents of \wcp must be maintained until the system is rebooted to an approved state.
    \item It is not possible to corrupt the IMA policy, because IMA policies require a signature.
  \end{itemize}
  \item When the system is booted in an approved state (IMA and SELinux working as intended), it is not possible to:
  \begin{itemize}
    \item Give unapproved programs the \lstinline|tpm_sign_exec_t| label
    \item Corrupt the \tpmsign binary to leak information
    \item Change the label of \wcp
    \item Corrupt the IMA or SELinux policies
  \end{itemize}
\end{itemize}

This method is not necessarily safe to attacks that can leak arbitrary program memory, like side-channel attacks.
Our \tpmsign binary is short-lived to minimize the surface area for these attacks.
We can also demonstrate a rootkit that corrupts IMA and/or SELinux features, bypassing our protections.
However, on a well-protected system, especially in a setup where IMA checks kernel modules, it would be very difficult to actually install this rootkit.
Thus, we believe bypassing our protections on an otherwise uncorrputed kernel has equivalent difficulty to finding at least one zero-day exploit.

\section{Limitations}
There are three primary limitations of this secret protection scheme.
The first is in real-world scenarios, strong IMA policies (protecting infrastructure other than ours) can make systems annoying to change or update.
This is a recognized problem and work is being done to mitigate this---for example,
by making restrictions on approved kernel modules more practical---but such improvements are not yet widely deployed.
% TODO: cite

The second limitation is assuming IMA and SELinux protections are not bypassed under an approved boot.
Against an adversary capable of bypassing SELinux and IMA, installing a rootkit, or otherwise corrupting the kernel at runtime,
the contents of \wcp can be leaked such that it, and thus \pk, will be persistently available to the adversary until boot PCRs change (e.g. via a system update),
regardless of the state of SELinux and IMA.
This also results in the desire for an immutable SELinux policy.
% ? Attacks in the vein of rootkits disabling SELinux/IMA functionality are demonstrable.

The final limitation is the speed of the TPM.
A non-virtualized TPM typically takes a few hundred milliseconds to complete the sequence of operations required for signing.
Thus, the TPM is a limiting factor for environments that would need high-frequency operations.
The slow speed of the TPM is considered a design feature to limit attack surface area. % ? TODO: cite
Alternative hardware security modules or virtualized TPMs may improve on this.

\section{Variations and Alternatives}
Reprovisioning \wcp for every boot may be viable by requiring a check for the boot-count, a feature supported by TPM policies.
Alternatively, reprovisioning \pk on every approved boot may be feasible in some environments, checking via a TPM quote to verify PCRs.
These would restrict runtime leaks to one boot cycle, however they would complicate policy or key management respectively, especially for remote parties.

Trusted Execution Environments may provide strong memory-based protections,
potentially sufficient to justify storing \pk in memory,
but are not always available on non-enterprise hardware.

A bespoke kernel module protecting \wcp may be an alternative to developing complex SELinux and IMA policies, and
a unified kernel image could be utilized to reduce the boot TCB.

We particularly believe implementing support for TPM localities on Linux and SELinux (or equivalent) to
restrict access of TPM localities to certain programs would be a strong step forward.
In this scenario, leaking the contents of \wcp would not make \pk available to an adversary when the SELinux policy is still running,
since only \tpmsign would be able to access the appropriate locality.
However, adversaries capable of corrupting the kernel would still be able to work around this.




%
% 
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
%\bibliographystyle{splncs04}
\bibliographystyle{splncsnat}
%\bibliography{sldg}
\bibliography{bib/sldg}
%
\end{document}
